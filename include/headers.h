#pragma once

#include "utility.h"

namespace gputil {
	// these headers files were take from jitify: https://github.com/NVIDIA/jitify/
	// they are stripped down headers that are compatible with NVRTC

    static const char* jitsafe_header_preinclude_h = 
        "//// WAR for Thrust (which appears to have forgotten to include this in result_of_adaptable_function.h\n"
        "//#include <type_traits>\n"
        "//// WAR for Thrust (which appear to have forgotten to include this in error_code.h)\n"
        "//#include <string>\n"
        "// WAR for generics/shfl.h\n"
        "#define THRUST_STATIC_ASSERT(x)\n"
        "// WAR for CUB\n"
        "#ifdef __host__\n"
        "#undef __host__\n"
        "#endif\n"
        "#define __host__\n"
        "// WAR to allow exceptions to be parsed\n"
        "#define try\n"
        "#define catch(...)\n"
#if defined(_WIN32) || defined(_WIN64)
// WAR for NVRTC <= 11.0 not defining _WIN64.
		"#ifndef _WIN64\n"
		"#define _WIN64 1\n"
		"#endif\n"
#endif
;

    static const char* jitsafe_header_float_h =
        "#pragma once\n"
        "#define FLT_RADIX       2\n"
        "#define FLT_MANT_DIG    24\n"
        "#define DBL_MANT_DIG    53\n"
        "#define FLT_DIG         6\n"
        "#define DBL_DIG         15\n"
        "#define FLT_MIN_EXP     -125\n"
        "#define DBL_MIN_EXP     -1021\n"
        "#define FLT_MIN_10_EXP  -37\n"
        "#define DBL_MIN_10_EXP  -307\n"
        "#define FLT_MAX_EXP     128\n"
        "#define DBL_MAX_EXP     1024\n"
        "#define FLT_MAX_10_EXP  38\n"
        "#define DBL_MAX_10_EXP  308\n"
        "#define FLT_MAX         3.4028234e38f\n"
        "#define DBL_MAX         1.7976931348623157e308\n"
        "#define FLT_EPSILON     1.19209289e-7f\n"
        "#define DBL_EPSILON     2.220440492503130e-16\n"
        "#define FLT_MIN         1.1754943e-38f\n"
        "#define DBL_MIN         2.2250738585072013e-308\n"
        "#define FLT_ROUNDS      1\n"
        "#if defined __cplusplus && __cplusplus >= 201103L\n"
        "#define FLT_EVAL_METHOD 0\n"
        "#define DECIMAL_DIG     21\n"
        "#endif\n";

    static const char* jitsafe_header_limits_h =
        "#pragma once\n"
        "#if defined _WIN32 || defined _WIN64\n"
        " #define __WORDSIZE 32\n"
        "#else\n"
        " #if defined(__LP64__) || (defined __x86_64__ && !defined __ILP32__)\n"
        "  #define __WORDSIZE 64\n"
        " #else\n"
        "  #define __WORDSIZE 32\n"
        " #endif\n"
        "#endif\n"
        "#define MB_LEN_MAX  16\n"
        "#define CHAR_BIT    8\n"
        "#define SCHAR_MIN   (-128)\n"
        "#define SCHAR_MAX   127\n"
        "#define UCHAR_MAX   255\n"
        "enum {\n"
        "  _JITIFY_CHAR_IS_UNSIGNED = (char)-1 >= 0,\n"
        "  CHAR_MIN = _JITIFY_CHAR_IS_UNSIGNED ? 0 : SCHAR_MIN,\n"
        "  CHAR_MAX = _JITIFY_CHAR_IS_UNSIGNED ? UCHAR_MAX : SCHAR_MAX,\n"
        "};\n"
        "#define SHRT_MIN    (-SHRT_MAX - 1)\n"
        "#define SHRT_MAX    0x7fff\n"
        "#define USHRT_MAX   0xffff\n"
        "#define INT_MIN     (-INT_MAX - 1)\n"
        "#define INT_MAX     0x7fffffff\n"
        "#define UINT_MAX    0xffffffff\n"
        "#if __WORDSIZE == 64\n"
        " # define LONG_MAX  LLONG_MAX\n"
        "#else\n"
        " # define LONG_MAX  UINT_MAX\n"
        "#endif\n"
        "#define LONG_MIN    (-LONG_MAX - 1)\n"
        "#if __WORDSIZE == 64\n"
        " #define ULONG_MAX  ULLONG_MAX\n"
        "#else\n"
        " #define ULONG_MAX  UINT_MAX\n"
        "#endif\n"
        "#define LLONG_MAX  0x7fffffffffffffff\n"
        "#define LLONG_MIN  (-LLONG_MAX - 1)\n"
        "#define ULLONG_MAX 0xffffffffffffffff\n";

    static const char* jitsafe_header_iterator =
        "#pragma once\n"
        "namespace std {\n"
        "struct output_iterator_tag {};\n"
        "struct input_iterator_tag {};\n"
        "struct forward_iterator_tag {};\n"
        "struct bidirectional_iterator_tag {};\n"
        "struct random_access_iterator_tag {};\n"
        "template<class Iterator>\n"
        "struct iterator_traits {\n"
        "  typedef typename Iterator::iterator_category iterator_category;\n"
        "  typedef typename Iterator::value_type        value_type;\n"
        "  typedef typename Iterator::difference_type   difference_type;\n"
        "  typedef typename Iterator::pointer           pointer;\n"
        "  typedef typename Iterator::reference         reference;\n"
        "};\n"
        "template<class T>\n"
        "struct iterator_traits<T*> {\n"
        "  typedef random_access_iterator_tag iterator_category;\n"
        "  typedef T                          value_type;\n"
        "  typedef ptrdiff_t                  difference_type;\n"
        "  typedef T*                         pointer;\n"
        "  typedef T&                         reference;\n"
        "};\n"
        "template<class T>\n"
        "struct iterator_traits<T const*> {\n"
        "  typedef random_access_iterator_tag iterator_category;\n"
        "  typedef T                          value_type;\n"
        "  typedef ptrdiff_t                  difference_type;\n"
        "  typedef T const*                   pointer;\n"
        "  typedef T const&                   reference;\n"
        "};\n"
        "}  // namespace std\n";

    // TODO: this is incomplete; need floating point limits
    static const char* jitsafe_header_limits = 
        "#pragma once\n"
        "#include <cfloat>\n"
        "#include <climits>\n"
        "#include <cstdint>\n"
        "// TODO: epsilon(), infinity(), etc\n"
        "namespace std {\n"
        "namespace __jitify_detail {\n"
        "#if __cplusplus >= 201103L\n"
        "#define JITIFY_CXX11_CONSTEXPR constexpr\n"
        "#define JITIFY_CXX11_NOEXCEPT noexcept\n"
        "#else\n"
        "#define JITIFY_CXX11_CONSTEXPR\n"
        "#define JITIFY_CXX11_NOEXCEPT\n"
        "#endif\n"
        "struct FloatLimits {\n"
        "#if __cplusplus >= 201103L\n"
        "   static JITIFY_CXX11_CONSTEXPR inline __host__ __device__ \n"
        "          float lowest() JITIFY_CXX11_NOEXCEPT {   return -FLT_MAX;}\n"
        "   static JITIFY_CXX11_CONSTEXPR inline __host__ __device__ \n"
        "          float min() JITIFY_CXX11_NOEXCEPT {      return FLT_MIN; }\n"
        "   static JITIFY_CXX11_CONSTEXPR inline __host__ __device__ \n"
        "          float max() JITIFY_CXX11_NOEXCEPT {      return FLT_MAX; }\n"
        "#endif  // __cplusplus >= 201103L\n"
        "   enum {\n"
        "   is_specialized    = true,\n"
        "   is_signed         = true,\n"
        "   is_integer        = false,\n"
        "   is_exact          = false,\n"
        "   has_infinity      = true,\n"
        "   has_quiet_NaN     = true,\n"
        "   has_signaling_NaN = true,\n"
        "   has_denorm        = 1,\n"
        "   has_denorm_loss   = true,\n"
        "   round_style       = 1,\n"
        "   is_iec559         = true,\n"
        "   is_bounded        = true,\n"
        "   is_modulo         = false,\n"
        "   digits            = 24,\n"
        "   digits10          = 6,\n"
        "   max_digits10      = 9,\n"
        "   radix             = 2,\n"
        "   min_exponent      = -125,\n"
        "   min_exponent10    = -37,\n"
        "   max_exponent      = 128,\n"
        "   max_exponent10    = 38,\n"
        "   tinyness_before   = false,\n"
        "   traps             = false\n"
        "   };\n"
        "};\n"
        "struct DoubleLimits {\n"
        "#if __cplusplus >= 201103L\n"
        "   static JITIFY_CXX11_CONSTEXPR inline __host__ __device__ \n"
        "          double lowest() noexcept { return -DBL_MAX; }\n"
        "   static JITIFY_CXX11_CONSTEXPR inline __host__ __device__ \n"
        "          double min() noexcept { return DBL_MIN; }\n"
        "   static JITIFY_CXX11_CONSTEXPR inline __host__ __device__ \n"
        "          double max() noexcept { return DBL_MAX; }\n"
        "#endif  // __cplusplus >= 201103L\n"
        "   enum {\n"
        "   is_specialized    = true,\n"
        "   is_signed         = true,\n"
        "   is_integer        = false,\n"
        "   is_exact          = false,\n"
        "   has_infinity      = true,\n"
        "   has_quiet_NaN     = true,\n"
        "   has_signaling_NaN = true,\n"
        "   has_denorm        = 1,\n"
        "   has_denorm_loss   = true,\n"
        "   round_style       = 1,\n"
        "   is_iec559         = true,\n"
        "   is_bounded        = true,\n"
        "   is_modulo         = false,\n"
        "   digits            = 53,\n"
        "   digits10          = 15,\n"
        "   max_digits10      = 17,\n"
        "   radix             = 2,\n"
        "   min_exponent      = -1021,\n"
        "   min_exponent10    = -307,\n"
        "   max_exponent      = 1024,\n"
        "   max_exponent10    = 308,\n"
        "   tinyness_before   = false,\n"
        "   traps             = false\n"
        "   };\n"
        "};\n"
        "template<class T, T Min, T Max, int Digits=-1>\n"
        "struct IntegerLimits {\n"
        "	static inline __host__ __device__ T min() { return Min; }\n"
        "	static inline __host__ __device__ T max() { return Max; }\n"
        "#if __cplusplus >= 201103L\n"
        "	static constexpr inline __host__ __device__ T lowest() noexcept {\n"
        "		return Min;\n"
        "	}\n"
        "#endif  // __cplusplus >= 201103L\n"
        "	enum {\n"
        "       is_specialized = true,\n"
        "       digits            = (Digits == -1) ? (int)(sizeof(T)*8 - (Min != 0)) : Digits,\n"
        "       digits10          = (digits * 30103) / 100000,\n"
        "       is_signed         = ((T)(-1)<0),\n"
        "       is_integer        = true,\n"
        "       is_exact          = true,\n"
        "       has_infinity      = false,\n"
        "       has_quiet_NaN     = false,\n"
        "       has_signaling_NaN = false,\n"
        "       has_denorm        = 0,\n"
        "       has_denorm_loss   = false,\n"
        "       round_style       = 0,\n"
        "       is_iec559         = false,\n"
        "       is_bounded        = true,\n"
        "       is_modulo         = !(is_signed || Max == 1 /*is bool*/),\n"
        "       max_digits10      = 0,\n"
        "       radix             = 2,\n"
        "       min_exponent      = 0,\n"
        "       min_exponent10    = 0,\n"
        "       max_exponent      = 0,\n"
        "       max_exponent10    = 0,\n"
        "       tinyness_before   = false,\n"
        "       traps             = false\n"
        "	};\n"
        "};\n"
        "} // namespace __jitify_detail\n"
        "template<typename T> struct numeric_limits {\n"
        "    enum { is_specialized = false };\n"
        "};\n"
        "template<> struct numeric_limits<bool>               : public \n"
        "__jitify_detail::IntegerLimits<bool,              false,    true,1> {};\n"
        "template<> struct numeric_limits<char>               : public \n"
        "__jitify_detail::IntegerLimits<char,              CHAR_MIN, CHAR_MAX> \n"
        "{};\n"
        "template<> struct numeric_limits<signed char>        : public \n"
        "__jitify_detail::IntegerLimits<signed char,       SCHAR_MIN,SCHAR_MAX> \n"
        "{};\n"
        "template<> struct numeric_limits<unsigned char>      : public \n"
        "__jitify_detail::IntegerLimits<unsigned char,     0,        UCHAR_MAX> \n"
        "{};\n"
        "template<> struct numeric_limits<wchar_t>            : public \n"
        "__jitify_detail::IntegerLimits<wchar_t,           WCHAR_MIN, WCHAR_MAX> {};\n"
        "template<> struct numeric_limits<short>              : public \n"
        "__jitify_detail::IntegerLimits<short,             SHRT_MIN, SHRT_MAX> \n"
        "{};\n"
        "template<> struct numeric_limits<unsigned short>     : public \n"
        "__jitify_detail::IntegerLimits<unsigned short,    0,        USHRT_MAX> \n"
        "{};\n"
        "template<> struct numeric_limits<int>                : public \n"
        "__jitify_detail::IntegerLimits<int,               INT_MIN,  INT_MAX> {};\n"
        "template<> struct numeric_limits<unsigned int>       : public \n"
        "__jitify_detail::IntegerLimits<unsigned int,      0,        UINT_MAX> \n"
        "{};\n"
        "template<> struct numeric_limits<long>               : public \n"
        "__jitify_detail::IntegerLimits<long,              LONG_MIN, LONG_MAX> \n"
        "{};\n"
        "template<> struct numeric_limits<unsigned long>      : public \n"
        "__jitify_detail::IntegerLimits<unsigned long,     0,        ULONG_MAX> \n"
        "{};\n"
        "template<> struct numeric_limits<long long>          : public \n"
        "__jitify_detail::IntegerLimits<long long,         LLONG_MIN,LLONG_MAX> \n"
        "{};\n"
        "template<> struct numeric_limits<unsigned long long> : public \n"
        "__jitify_detail::IntegerLimits<unsigned long long,0,        ULLONG_MAX> \n"
        "{};\n"
        "//template<typename T> struct numeric_limits { static const bool \n"
        "//is_signed = ((T)(-1)<0); };\n"
        "template<> struct numeric_limits<float>              : public \n"
        "__jitify_detail::FloatLimits \n"
        "{};\n"
        "template<> struct numeric_limits<double>             : public \n"
        "__jitify_detail::DoubleLimits \n"
        "{};\n"
        "}  // namespace std\n";

    // TODO: this is highly incomplete
    static const char* jitsafe_header_type_traits = 
        "#pragma once\n"
        "#if __cplusplus >= 201103L\n"
        "namespace std {\n"
        "template<bool B, class T = void> struct enable_if {};\n"
        "template<class T>                struct enable_if<true, T> { typedef T type; };\n"
        "#if __cplusplus >= 201402L\n"
        "template< bool B, class T = void > using enable_if_t = typename enable_if<B,T>::type;\n"
        "#endif\n"
        "struct true_type  {\n"
        "  enum { value = true };\n"
        "  operator bool() const { return true; }\n"
        "};\n"
        "struct false_type {\n"
        "  enum { value = false };\n"
        "  operator bool() const { return false; }\n"
        "};\n"
        "template<typename T> struct is_floating_point    : false_type {};\n"
        "template<> struct is_floating_point<float>       :  true_type {};\n"
        "template<> struct is_floating_point<double>      :  true_type {};\n"
        "template<> struct is_floating_point<long double> :  true_type {};\n"
        "#if __cplusplus >= 201703L\n"
        "template<typename T> inline constexpr bool is_floating_point_v = is_floating_point<T>::value;\n"
        "#endif  // __cplusplus >= 201703L\n"
        "template<class T> struct is_integral              : false_type {};\n"
        "template<> struct is_integral<bool>               :  true_type {};\n"
        "template<> struct is_integral<char>               :  true_type {};\n"
        "template<> struct is_integral<signed char>        :  true_type {};\n"
        "template<> struct is_integral<unsigned char>      :  true_type {};\n"
        "template<> struct is_integral<short>              :  true_type {};\n"
        "template<> struct is_integral<unsigned short>     :  true_type {};\n"
        "template<> struct is_integral<int>                :  true_type {};\n"
        "template<> struct is_integral<unsigned int>       :  true_type {};\n"
        "template<> struct is_integral<long>               :  true_type {};\n"
        "template<> struct is_integral<unsigned long>      :  true_type {};\n"
        "template<> struct is_integral<long long>          :  true_type {};\n"
        "template<> struct is_integral<unsigned long long> :  true_type {};\n"
        "#if __cplusplus >= 201703L\n"
        "template<typename T> inline constexpr bool is_integral_v = is_integral<T>::value;\n"
        "#endif  // __cplusplus >= 201703L\n"
        "template<typename T> struct is_signed    : false_type {};\n"
        "template<> struct is_signed<float>       :  true_type {};\n"
        "template<> struct is_signed<double>      :  true_type {};\n"
        "template<> struct is_signed<long double> :  true_type {};\n"
        "template<> struct is_signed<signed char> :  true_type {};\n"
        "template<> struct is_signed<short>       :  true_type {};\n"
        "template<> struct is_signed<int>         :  true_type {};\n"
        "template<> struct is_signed<long>        :  true_type {};\n"
        "template<> struct is_signed<long long>   :  true_type {};\n"
        "template<typename T> struct is_unsigned             : false_type {};\n"
        "template<> struct is_unsigned<unsigned char>      :  true_type {};\n"
        "template<> struct is_unsigned<unsigned short>     :  true_type {};\n"
        "template<> struct is_unsigned<unsigned int>       :  true_type {};\n"
        "template<> struct is_unsigned<unsigned long>      :  true_type {};\n"
        "template<> struct is_unsigned<unsigned long long> :  true_type {};\n"
        "template<typename T, typename U> struct is_same      : false_type {};\n"
        "template<typename T>             struct is_same<T,T> :  true_type {};\n"
        "#if __cplusplus >= 201703L\n"
        "template<typename T, typename U> inline constexpr bool is_same_v = is_same<T, U>::value;\n"
        "#endif  // __cplusplus >= 201703L\n"
        "template<class T> struct is_array : false_type {};\n"
        "template<class T> struct is_array<T[]> : true_type {};\n"
        "template<class T, size_t N> struct is_array<T[N]> : true_type {};\n"
        "//partial implementation only of is_function\n"
        "template<class> struct is_function : false_type { };\n"
        "template<class Ret, class... Args> struct is_function<Ret(Args...)> : true_type {}; //regular\n"
        "template<class Ret, class... Args> struct is_function<Ret(Args......)> : true_type {}; // variadic\n"
        "template<class> struct result_of;\n"
        "template<class F, typename... Args>\n"
        "struct result_of<F(Args...)> {\n"
        "// TODO: This is a hack; a proper implem is quite complicated.\n"
        "typedef typename F::result_type type;\n"
        "};\n"
        "template<class T> struct is_pointer                    : false_type {};\n"
        "template<class T> struct is_pointer<T*>                : true_type {};\n"
        "template<class T> struct is_pointer<T* const>          : true_type {};\n"
        "template<class T> struct is_pointer<T* volatile>       : true_type {};\n"
        "template<class T> struct is_pointer<T* const volatile> : true_type {};\n"
        "#if __cplusplus >= 201703L\n"
        "template< class T > inline constexpr bool is_pointer_v = is_pointer<T>::value;\n"
        "#endif  // __cplusplus >= 201703L\n"
        "template <class T> struct remove_pointer { typedef T type; };\n"
        "template <class T> struct remove_pointer<T*> { typedef T type; };\n"
        "template <class T> struct remove_pointer<T* const> { typedef T type; };\n"
        "template <class T> struct remove_pointer<T* volatile> { typedef T type; };\n"
        "template <class T> struct remove_pointer<T* const volatile> { typedef T type; };\n"
        "template <class T> struct remove_reference { typedef T type; };\n"
        "template <class T> struct remove_reference<T&> { typedef T type; };\n"
        "template <class T> struct remove_reference<T&&> { typedef T type; };\n"
        "#if __cplusplus >= 201402L\n"
        "template< class T > using remove_reference_t = typename remove_reference<T>::type;\n"
        "#endif\n"
        "template<class T> struct remove_extent { typedef T type; };\n"
        "template<class T> struct remove_extent<T[]> { typedef T type; };\n"
        "template<class T, size_t N> struct remove_extent<T[N]> { typedef T type; };\n"
        "#if __cplusplus >= 201402L\n"
        "template< class T > using remove_extent_t = typename remove_extent<T>::type;\n"
        "#endif\n"
        "template< class T > struct remove_const          { typedef T type; };\n"
        "template< class T > struct remove_const<const T> { typedef T type; };\n"
        "template< class T > struct remove_volatile             { typedef T type; };\n"
        "template< class T > struct remove_volatile<volatile T> { typedef T type; };\n"
        "template< class T > struct remove_cv { typedef typename remove_volatile<typename remove_const<T>::type>::type type; };\n"
        "#if __cplusplus >= 201402L\n"
        "template< class T > using remove_cv_t       = typename remove_cv<T>::type;\n"
        "template< class T > using remove_const_t    = typename remove_const<T>::type;\n"
        "template< class T > using remove_volatile_t = typename remove_volatile<T>::type;\n"
        "#endif\n"
        "template<bool B, class T, class F> struct conditional { typedef T type; };\n"
        "template<class T, class F> struct conditional<false, T, F> { typedef F type; };\n"
        "#if __cplusplus >= 201402L\n"
        "template< bool B, class T, class F > using conditional_t = typename conditional<B,T,F>::type;\n"
        "#endif\n"
        "namespace __jitify_detail {\n"
        "template< class T, bool is_function_type = false > struct add_pointer { using type = typename remove_reference<T>::type*; };\n"
        "template< class T > struct add_pointer<T, true> { using type = T; };\n"
        "template< class T, class... Args > struct add_pointer<T(Args...), true> { using type = T(*)(Args...); };\n"
        "template< class T, class... Args > struct add_pointer<T(Args..., ...), true> { using type = T(*)(Args..., ...); };\n"
        "}  // namespace __jitify_detail\n"
        "template< class T > struct add_pointer : __jitify_detail::add_pointer<T, is_function<T>::value> {};\n"
        "#if __cplusplus >= 201402L\n"
        "template< class T > using add_pointer_t = typename add_pointer<T>::type;\n"
        "#endif\n"
        "template< class T > struct decay {\n"
        "private:\n"
        "  typedef typename remove_reference<T>::type U;\n"
        "public:\n"
        "  typedef typename conditional<is_array<U>::value, typename remove_extent<U>::type*,\n"
        "    typename conditional<is_function<U>::value,typename add_pointer<U>::type,typename remove_cv<U>::type\n"
        "    >::type>::type type;\n"
        "};\n"
        "#if __cplusplus >= 201402L\n"
        "template< class T > using decay_t = typename decay<T>::type;\n"
        "#endif\n"
        "template<class T, T v>\n"
        "struct integral_constant {\n"
        "static constexpr T value = v;\n"
        "typedef T value_type;\n"
        "typedef integral_constant type; // using injected-class-name\n"
        "constexpr operator value_type() const noexcept { return value; }\n"
        "#if __cplusplus >= 201402L\n"
        "constexpr value_type operator()() const noexcept { return value; }\n"
        "#endif\n"
        "};\n"
        "template<typename T> struct is_arithmetic :\n"
        "std::integral_constant<bool, std::is_integral<T>::value ||\n"
        "                             std::is_floating_point<T>::value> {};\n"
        "#if __cplusplus >= 201703L\n"
        "template<typename T> inline constexpr bool is_arithmetic_v = is_arithmetic<T>::value;\n"
        "#endif  // __cplusplus >= 201703L\n"
        "template<class T> struct is_lvalue_reference : false_type {};\n"
        "template<class T> struct is_lvalue_reference<T&> : true_type {};\n"
        "template<class T> struct is_rvalue_reference : false_type {};\n"
        "template<class T> struct is_rvalue_reference<T&&> : true_type {};\n"
        "namespace __jitify_detail {\n"
        "template <class T> struct type_identity { using type = T; };\n"
        "template <class T> auto add_lvalue_reference(int) -> type_identity<T&>;\n"
        "template <class T> auto add_lvalue_reference(...) -> type_identity<T>;\n"
        "template <class T> auto add_rvalue_reference(int) -> type_identity<T&&>;\n"
        "template <class T> auto add_rvalue_reference(...) -> type_identity<T>;\n"
        "} // namespace _jitify_detail\n"
        "template <class T> struct add_lvalue_reference : decltype(__jitify_detail::add_lvalue_reference<T>(0)) {};\n"
        "template <class T> struct add_rvalue_reference : decltype(__jitify_detail::add_rvalue_reference<T>(0)) {};\n"
        "#if __cplusplus >= 201402L\n"
        "template <class T> using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;\n"
        "template <class T> using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;\n"
        "#endif\n"
        "template<typename T> struct is_const          : public false_type {};\n"
        "template<typename T> struct is_const<const T> : public true_type {};\n"
        "template<typename T> struct is_volatile             : public false_type {};\n"
        "template<typename T> struct is_volatile<volatile T> : public true_type {};\n"
        "template<typename T> struct is_void             : public false_type {};\n"
        "template<>           struct is_void<void>       : public true_type {};\n"
        "template<>           struct is_void<const void> : public true_type {};\n"
        "template<typename T> struct is_reference     : public false_type {};\n"
        "template<typename T> struct is_reference<T&> : public true_type {};\n"
        "template<typename _Tp, bool = (is_void<_Tp>::value || is_reference<_Tp>::value)>\n"
        "struct __add_reference_helper { typedef _Tp&    type; };\n"
        "template<typename _Tp> struct __add_reference_helper<_Tp, true> { typedef _Tp     type; };\n"
        "template<typename _Tp> struct add_reference : public __add_reference_helper<_Tp>{};\n"
        "namespace __jitify_detail {\n"
        "template<typename T> struct is_int_or_cref {\n"
        "typedef typename remove_reference<T>::type type_sans_ref;\n"
        "static const bool value = (is_integral<T>::value || (is_integral<type_sans_ref>::value\n"
        "  && is_const<type_sans_ref>::value && !is_volatile<type_sans_ref>::value));\n"
        "}; // end is_int_or_cref\n"
        "template<typename From, typename To> struct is_convertible_sfinae {\n"
        "private:\n"
        "typedef char                          yes;\n"
        "typedef struct { char two_chars[2]; } no;\n"
        "static inline yes   test(To) { return yes(); }\n"
        "static inline no    test(...) { return no(); }\n"
        "static inline typename remove_reference<From>::type& from() { typename remove_reference<From>::type* ptr = 0; return *ptr; }\n"
        "public:\n"
        "static const bool value = sizeof(test(from())) == sizeof(yes);\n"
        "}; // end is_convertible_sfinae\n"
        "template<typename From, typename To> struct is_convertible_needs_simple_test {\n"
        "static const bool from_is_void      = is_void<From>::value;\n"
        "static const bool to_is_void        = is_void<To>::value;\n"
        "static const bool from_is_float     = is_floating_point<typename remove_reference<From>::type>::value;\n"
        "static const bool to_is_int_or_cref = is_int_or_cref<To>::value;\n"
        "static const bool value = (from_is_void || to_is_void || (from_is_float && to_is_int_or_cref));\n"
        "}; // end is_convertible_needs_simple_test\n"
        "template<typename From, typename To, bool = is_convertible_needs_simple_test<From,To>::value>\n"
        "struct is_convertible {\n"
        "static const bool value = (is_void<To>::value || (is_int_or_cref<To>::value && !is_void<From>::value));\n"
        "}; // end is_convertible\n"
        "template<typename From, typename To> struct is_convertible<From, To, false> {\n"
        "static const bool value = (is_convertible_sfinae<typename add_reference<From>::type, To>::value);\n"
        "}; // end is_convertible\n"
        "} // end __jitify_detail\n"
        "// implementation of is_convertible taken from thrust's pre C++11 path\n"
        "template<typename From, typename To> struct is_convertible\n"
        ": public integral_constant<bool, __jitify_detail::is_convertible<From, To>::value>\n"
        "{ }; // end is_convertible\n"
        "template<class A, class B> struct is_base_of { };\n"
        "template<size_t len, size_t alignment> struct aligned_storage { struct type { alignas(alignment) char data[len]; }; };\n"
        "template <class T> struct alignment_of : std::integral_constant<size_t,alignof(T)> {};\n"
        "template <typename T> struct make_unsigned;\n"
        "template <> struct make_unsigned<signed char>        { typedef unsigned char type; };\n"
        "template <> struct make_unsigned<signed short>       { typedef unsigned short type; };\n"
        "template <> struct make_unsigned<signed int>         { typedef unsigned int type; };\n"
        "template <> struct make_unsigned<signed long>        { typedef unsigned long type; };\n"
        "template <> struct make_unsigned<signed long long>   { typedef unsigned long long type; };\n"
        "template <> struct make_unsigned<unsigned char>      { typedef unsigned char type; };\n"
        "template <> struct make_unsigned<unsigned short>     { typedef unsigned short type; };\n"
        "template <> struct make_unsigned<unsigned int>       { typedef unsigned int type; };\n"
        "template <> struct make_unsigned<unsigned long>      { typedef unsigned long type; };\n"
        "template <> struct make_unsigned<unsigned long long> { typedef unsigned long long type; };\n"
        "template <> struct make_unsigned<char>               { typedef unsigned char type; };\n"
        "#if defined _WIN32 || defined _WIN64\n"
        "template <> struct make_unsigned<wchar_t>            { typedef unsigned short type; };\n"
        "#else\n"
        "template <> struct make_unsigned<wchar_t>            { typedef unsigned int type; };\n"
        "#endif\n"
        "template <typename T> struct make_signed;\n"
        "template <> struct make_signed<signed char>        { typedef signed char type; };\n"
        "template <> struct make_signed<signed short>       { typedef signed short type; };\n"
        "template <> struct make_signed<signed int>         { typedef signed int type; };\n"
        "template <> struct make_signed<signed long>        { typedef signed long type; };\n"
        "template <> struct make_signed<signed long long>   { typedef signed long long type; };\n"
        "template <> struct make_signed<unsigned char>      { typedef signed char type; };\n"
        "template <> struct make_signed<unsigned short>     { typedef signed short type; };\n"
        "template <> struct make_signed<unsigned int>       { typedef signed int type; };\n"
        "template <> struct make_signed<unsigned long>      { typedef signed long type; };\n"
        "template <> struct make_signed<unsigned long long> { typedef signed long long type; };\n"
        "template <> struct make_signed<char>               { typedef signed char type; };\n"
        "#if defined _WIN32 || defined _WIN64\n"
        "template <> struct make_signed<wchar_t>            { typedef signed short type; };\n"
        "#else\n"
        "template <> struct make_signed<wchar_t>            { typedef signed int type; };\n"
        "#endif\n"
        "}  // namespace std\n"
        "#endif // c++11\n";

    // TODO: INT_FAST8_MAX et al. and a few other misc constants
    static const char* jitsafe_header_stdint_h =
        "#pragma once\n"
        "#include <climits>\n"
        "namespace __jitify_stdint_ns {\n"
        "typedef signed char      int8_t;\n"
        "typedef signed short     int16_t;\n"
        "typedef signed int       int32_t;\n"
        "typedef signed long long int64_t;\n"
        "typedef signed char      int_fast8_t;\n"
        "typedef signed short     int_fast16_t;\n"
        "typedef signed int       int_fast32_t;\n"
        "typedef signed long long int_fast64_t;\n"
        "typedef signed char      int_least8_t;\n"
        "typedef signed short     int_least16_t;\n"
        "typedef signed int       int_least32_t;\n"
        "typedef signed long long int_least64_t;\n"
        "typedef signed long long intmax_t;\n"
        "typedef signed long      intptr_t; //optional\n"
        "typedef unsigned char      uint8_t;\n"
        "typedef unsigned short     uint16_t;\n"
        "typedef unsigned int       uint32_t;\n"
        "typedef unsigned long long uint64_t;\n"
        "typedef unsigned char      uint_fast8_t;\n"
        "typedef unsigned short     uint_fast16_t;\n"
        "typedef unsigned int       uint_fast32_t;\n"
        "typedef unsigned long long uint_fast64_t;\n"
        "typedef unsigned char      uint_least8_t;\n"
        "typedef unsigned short     uint_least16_t;\n"
        "typedef unsigned int       uint_least32_t;\n"
        "typedef unsigned long long uint_least64_t;\n"
        "typedef unsigned long long uintmax_t;\n"
        "#define INT8_MIN    SCHAR_MIN\n"
        "#define INT16_MIN   SHRT_MIN\n"
        "#if defined _WIN32 || defined _WIN64\n"
        "#define WCHAR_MIN   0\n"
        "#define WCHAR_MAX   USHRT_MAX\n"
        "typedef unsigned long long uintptr_t; //optional\n"
        "#else\n"
        "#define WCHAR_MIN   INT_MIN\n"
        "#define WCHAR_MAX   INT_MAX\n"
        "typedef unsigned long      uintptr_t; //optional\n"
        "#endif\n"
        "#define INT32_MIN   INT_MIN\n"
        "#define INT64_MIN   LLONG_MIN\n"
        "#define INT8_MAX    SCHAR_MAX\n"
        "#define INT16_MAX   SHRT_MAX\n"
        "#define INT32_MAX   INT_MAX\n"
        "#define INT64_MAX   LLONG_MAX\n"
        "#define UINT8_MAX   UCHAR_MAX\n"
        "#define UINT16_MAX  USHRT_MAX\n"
        "#define UINT32_MAX  UINT_MAX\n"
        "#define UINT64_MAX  ULLONG_MAX\n"
        "#define INTPTR_MIN  LONG_MIN\n"
        "#define INTMAX_MIN  LLONG_MIN\n"
        "#define INTPTR_MAX  LONG_MAX\n"
        "#define INTMAX_MAX  LLONG_MAX\n"
        "#define UINTPTR_MAX ULONG_MAX\n"
        "#define UINTMAX_MAX ULLONG_MAX\n"
        "#define PTRDIFF_MIN INTPTR_MIN\n"
        "#define PTRDIFF_MAX INTPTR_MAX\n"
        "#define SIZE_MAX    UINT64_MAX\n"
        "} // namespace __jitify_stdint_ns\n"
        "namespace std { using namespace __jitify_stdint_ns; }\n"
        "using namespace __jitify_stdint_ns;\n";

    // TODO: offsetof
    static const char* jitsafe_header_stddef_h =
        "#pragma once\n"
        "#include <climits>\n"
        "namespace __jitify_stddef_ns {\n"
        "#if __cplusplus >= 201103L\n"
        "typedef decltype(nullptr) nullptr_t;\n"
        "#if defined(_MSC_VER)\n"
        "  typedef double max_align_t;\n"
        "#elif defined(__APPLE__)\n"
        "  typedef long double max_align_t;\n"
        "#else\n"
        "  // Define max_align_t to match the GCC definition.\n"
        "  typedef struct {\n"
        "    long long __jitify_max_align_nonce1\n"
        "        __attribute__((__aligned__(__alignof__(long long))));\n"
        "    long double __jitify_max_align_nonce2\n"
        "        __attribute__((__aligned__(__alignof__(long double))));\n"
        "  } max_align_t;\n"
        "#endif\n"
        "#endif  // __cplusplus >= 201103L\n"
        "#if __cplusplus >= 201703L\n"
        "enum class byte : unsigned char {};\n"
        "#endif  // __cplusplus >= 201703L\n"
        "} // namespace __jitify_stddef_ns\n"
        "namespace std {\n"
        "  // NVRTC provides built-in definitions of ::size_t and ::ptrdiff_t.\n"
        "  using ::size_t;\n"
        "  using ::ptrdiff_t;\n"
        "  using namespace __jitify_stddef_ns;\n"
        "} // namespace std\n"
        "using namespace __jitify_stddef_ns;\n";

    static const char* jitsafe_header_stdlib_h =
        "#pragma once\n"
        "#include <stddef.h>\n";

    static const char* jitsafe_header_stdio_h =
        "#pragma once\n"
        "#include <stddef.h>\n"
        "#define FILE int\n"
        "int fflush ( FILE * stream );\n"
        "int fprintf ( FILE * stream, const char * format, ... );\n";

    static const char* jitsafe_header_string_h =
        "#pragma once\n"
        "char* strcpy ( char * destination, const char * source );\n"
        "int strcmp ( const char * str1, const char * str2 );\n"
        "char* strerror( int errnum );\n";

    static const char* jitsafe_header_cstring =
        "#pragma once\n"
        "\n"
        "namespace __jitify_cstring_ns {\n"
        "char* strcpy ( char * destination, const char * source );\n"
        "int strcmp ( const char * str1, const char * str2 );\n"
        "char* strerror( int errnum );\n"
        "} // namespace __jitify_cstring_ns\n"
        "namespace std { using namespace __jitify_cstring_ns; }\n"
        "using namespace __jitify_cstring_ns;\n";

    static const char* jitsafe_header_iostream =
        "#pragma once\n"
        "#include <ostream>\n"
        "#include <istream>\n";
    static const char* jitsafe_header_ostream =
        "#pragma once\n"
        "\n"
        "namespace std {\n"
        "template<class CharT,class Traits=void>\n"  // = std::char_traits<CharT>
                                                     // >\n"
        "struct basic_ostream {\n"
        "};\n"
        "typedef basic_ostream<char> ostream;\n"
        "ostream& endl(ostream& os);\n"
        "ostream& operator<<( ostream&, ostream& (*f)( ostream& ) );\n"
        "template< class CharT, class Traits > basic_ostream<CharT, Traits>& endl( "
        "basic_ostream<CharT, Traits>& os );\n"
        "template< class CharT, class Traits > basic_ostream<CharT, Traits>& "
        "operator<<( basic_ostream<CharT,Traits>& os, const char* c );\n"
        "#if __cplusplus >= 201103L\n"
        "template< class CharT, class Traits, class T > basic_ostream<CharT, "
        "Traits>& operator<<( basic_ostream<CharT,Traits>&& os, const T& value );\n"
        "#endif  // __cplusplus >= 201103L\n"
        "}  // namespace std\n";

    static const char* jitsafe_header_istream =
        "#pragma once\n"
        "\n"
        "namespace std {\n"
        "template<class CharT,class Traits=void>\n"  // = std::char_traits<CharT>
                                                     // >\n"
        "struct basic_istream {\n"
        "};\n"
        "typedef basic_istream<char> istream;\n"
        "}  // namespace std\n";

    static const char* jitsafe_header_sstream =
        "#pragma once\n"
        "#include <ostream>\n"
        "#include <istream>\n";

    static const char* jitsafe_header_utility =
        "#pragma once\n"
        "namespace std {\n"
        "template<class T1, class T2>\n"
        "struct pair {\n"
        "	T1 first;\n"
        "	T2 second;\n"
        "	inline pair() {}\n"
        "	inline pair(T1 const& first_, T2 const& second_)\n"
        "		: first(first_), second(second_) {}\n"
        "	// TODO: Standard includes many more constructors...\n"
        "	// TODO: Comparison operators\n"
        "};\n"
        "template<class T1, class T2>\n"
        "pair<T1,T2> make_pair(T1 const& first, T2 const& second) {\n"
        "	return pair<T1,T2>(first, second);\n"
        "}\n"
        "}  // namespace std\n";

    // TODO: incomplete
    static const char* jitsafe_header_vector =
        "#pragma once\n"
        "namespace std {\n"
        "template<class T, class Allocator=void>\n"  // = std::allocator> \n"
        "struct vector {\n"
        "};\n"
        "}  // namespace std\n";

    // TODO: incomplete
    static const char* jitsafe_header_string =
        "#pragma once\n"
        "namespace std {\n"
        "template<class CharT,class Traits=void,class Allocator=void>\n"
        "struct basic_string {\n"
        "basic_string();\n"
        "basic_string( const CharT* s );\n"  //, const Allocator& alloc =
                                             // Allocator() );\n"
        "const CharT* c_str() const;\n"
        "bool empty() const;\n"
        "void operator+=(const char *);\n"
        "void operator+=(const basic_string &);\n"
        "};\n"
        "typedef basic_string<char> string;\n"
        "}  // namespace std\n";

    // TODO: incomplete
    static const char* jitsafe_header_stdexcept =
        "#pragma once\n"
        "namespace std {\n"
        "struct runtime_error {\n"
        "explicit runtime_error( const std::string& what_arg );"
        "explicit runtime_error( const char* what_arg );"
        "virtual const char* what() const;\n"
        "};\n"
        "}  // namespace std\n";

    // TODO: incomplete
    static const char* jitsafe_header_complex =
        "#pragma once\n"
        "namespace std {\n"
        "template<typename T>\n"
        "class complex {\n"
        "	T _real;\n"
        "	T _imag;\n"
        "public:\n"
        "	complex() : _real(0), _imag(0) {}\n"
        "	complex(T const& real, T const& imag)\n"
        "		: _real(real), _imag(imag) {}\n"
        "	complex(T const& real)\n"
        "               : _real(real), _imag(static_cast<T>(0)) {}\n"
        "	T const& real() const { return _real; }\n"
        "	T&       real()       { return _real; }\n"
        "	void real(const T &r) { _real = r; }\n"
        "	T const& imag() const { return _imag; }\n"
        "	T&       imag()       { return _imag; }\n"
        "	void imag(const T &i) { _imag = i; }\n"
        "       complex<T>& operator+=(const complex<T> z)\n"
        "         { _real += z.real(); _imag += z.imag(); return *this; }\n"
        "};\n"
        "template<typename T>\n"
        "complex<T> operator*(const complex<T>& lhs, const complex<T>& rhs)\n"
        "  { return complex<T>(lhs.real()*rhs.real()-lhs.imag()*rhs.imag(),\n"
        "                      lhs.real()*rhs.imag()+lhs.imag()*rhs.real()); }\n"
        "template<typename T>\n"
        "complex<T> operator*(const complex<T>& lhs, const T & rhs)\n"
        "  { return complexs<T>(lhs.real()*rhs,lhs.imag()*rhs); }\n"
        "template<typename T>\n"
        "complex<T> operator*(const T& lhs, const complex<T>& rhs)\n"
        "  { return complexs<T>(rhs.real()*lhs,rhs.imag()*lhs); }\n"
        "}  // namespace std\n";

    // TODO: this is incomplete (missing binary and integer funcs, macros, constants, types)
    static const char* jitsafe_header_math_h =
        "#pragma once\n"
        "namespace __jitify_math_ns {\n"
        "#if __cplusplus >= 201103L\n"
        "#define DEFINE_MATH_UNARY_FUNC_WRAPPER(f) \\\n"
        "	inline double      f(double x)         { return ::f(x); } \\\n"
        "	inline float       f##f(float x)       { return ::f(x); } \\\n"
        "	/*inline long double f##l(long double x) { return ::f(x); }*/ \\\n"
        "	inline float       f(float x)          { return ::f(x); } \\\n"
        "	/*inline long double f(long double x)    { return ::f(x); }*/\n"
        "#else\n"
        "#define DEFINE_MATH_UNARY_FUNC_WRAPPER(f) \\\n"
        "	inline double      f(double x)         { return ::f(x); } \\\n"
        "	inline float       f##f(float x)       { return ::f(x); } \\\n"
        "	/*inline long double f##l(long double x) { return ::f(x); }*/\n"
        "#endif\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(cos)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(sin)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(tan)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(acos)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(asin)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(atan)\n"
        "template<typename T> inline T atan2(T y, T x) { return ::atan2(y, x); }\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(cosh)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(sinh)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(tanh)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(exp)\n"
        "template<typename T> inline T frexp(T x, int* exp) { return ::frexp(x, "
        "exp); }\n"
        "template<typename T> inline T ldexp(T x, int  exp) { return ::ldexp(x, "
        "exp); }\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(log)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(log10)\n"
        "template<typename T> inline T modf(T x, T* intpart) { return ::modf(x, "
        "intpart); }\n"
        "template<typename T> inline T pow(T x, T y) { return ::pow(x, y); }\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(sqrt)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(ceil)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(floor)\n"
        "template<typename T> inline T fmod(T n, T d) { return ::fmod(n, d); }\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(fabs)\n"
        "template<typename T> inline T abs(T x) { return ::abs(x); }\n"
        "#if __cplusplus >= 201103L\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(acosh)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(asinh)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(atanh)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(exp2)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(expm1)\n"
        "template<typename T> inline int ilogb(T x) { return ::ilogb(x); }\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(log1p)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(log2)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(logb)\n"
        "template<typename T> inline T scalbn (T x, int n)  { return ::scalbn(x, "
        "n); }\n"
        "template<typename T> inline T scalbln(T x, long n) { return ::scalbn(x, "
        "n); }\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(cbrt)\n"
        "template<typename T> inline T hypot(T x, T y) { return ::hypot(x, y); }\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(erf)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(erfc)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(tgamma)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(lgamma)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(trunc)\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(round)\n"
        "template<typename T> inline long lround(T x) { return ::lround(x); }\n"
        "template<typename T> inline long long llround(T x) { return ::llround(x); "
        "}\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(rint)\n"
        "template<typename T> inline long lrint(T x) { return ::lrint(x); }\n"
        "template<typename T> inline long long llrint(T x) { return ::llrint(x); "
        "}\n"
        "DEFINE_MATH_UNARY_FUNC_WRAPPER(nearbyint)\n"
        // TODO: remainder, remquo, copysign, nan, nextafter, nexttoward, fdim,
        // fmax, fmin, fma
        "#endif\n"
        "#undef DEFINE_MATH_UNARY_FUNC_WRAPPER\n"
        "} // namespace __jitify_math_ns\n"
        "namespace std { using namespace __jitify_math_ns; }\n"
        "#define M_PI 3.14159265358979323846\n"
        // Note: Global namespace already includes CUDA math funcs
        "//using namespace __jitify_math_ns;\n";

    static const char* jitsafe_header_memory_h =
        "#pragma once"
        "#include <string.h>";

    // TODO: incomplete
    static const char* jitsafe_header_mutex =
        "#pragma once\n"
        "#if __cplusplus >= 201103L\n"
        "namespace std {\n"
        "class mutex {\n"
        "public:\n"
        "void lock();\n"
        "bool try_lock();\n"
        "void unlock();\n"
        "};\n"
        "}  // namespace std\n"
        "#endif\n";

    static const char* jitsafe_header_algorithm =
        "#pragma once\n"
        "#if __cplusplus >= 201103L\n"
        "namespace std {\n"
        "#if __cplusplus == 201103L\n"
        "#define JITIFY_CXX14_CONSTEXPR\n"
        "#else\n"
        "#define JITIFY_CXX14_CONSTEXPR constexpr\n"
        "#endif\n"
        "template<class T> JITIFY_CXX14_CONSTEXPR const T& max(const T& a, const T& b)\n"
        "{\n"
        "  return (b > a) ? b : a;\n"
        "}\n"
        "template<class T> JITIFY_CXX14_CONSTEXPR const T& min(const T& a, const T& b)\n"
        "{\n"
        "  return (b < a) ? b : a;\n"
        "}\n"
        "}  // namespace std\n"
        "#endif\n";

    static const char* jitsafe_header_time_h =
        "#pragma once\n"
        "#define NULL 0\n"
        "#define CLOCKS_PER_SEC 1000000\n"
        "namespace __jitify_time_ns {\n"
        "typedef long time_t;\n"
        "struct tm {\n"
        "  int tm_sec;\n"
        "  int tm_min;\n"
        "  int tm_hour;\n"
        "  int tm_mday;\n"
        "  int tm_mon;\n"
        "  int tm_year;\n"
        "  int tm_wday;\n"
        "  int tm_yday;\n"
        "  int tm_isdst;\n"
        "};\n"
        "#if __cplusplus >= 201703L\n"
        "struct timespec {\n"
        "  time_t tv_sec;\n"
        "  long tv_nsec;\n"
        "};\n"
        "#endif\n"
        "}  // namespace __jitify_time_ns\n"
        "namespace std {\n"
        "  // NVRTC provides built-in definitions of ::size_t and ::clock_t.\n"
        "  using ::size_t;\n"
        "  using ::clock_t;\n"
        "  using namespace __jitify_time_ns;\n"
        "}\n"
        "using namespace __jitify_time_ns;\n";

    static const char* jitsafe_header_tuple =
        "#pragma once\n"
        "#if __cplusplus >= 201103L\n"
        "namespace std {\n"
        "template<class... Types > class tuple;\n"
        "template< size_t I, class T >\n"
        "struct tuple_element;\n"
        "// recursive case\n"
        "template< size_t I, class Head, class... Tail >\n"
        "struct tuple_element<I, tuple<Head, Tail...>>\n"
        "    : tuple_element<I-1, tuple<Tail...>> { };\n"
        "// base case\n"
        "template< class Head, class... Tail >\n"
        "struct tuple_element<0, tuple<Head, Tail...>> {\n"
        "  using type = Head;\n"
        "};\n"
        "} // namespace std\n"
        "#endif\n";

    static const char* jitsafe_header_assert =
        "#pragma once\n";

    static const char* jitsafe_header_assert_h =
        "#ifndef __ASSERT_HEADER\n"
        "#define __ASSERT_HEADER\n"
        "#include \"stddef.h\"\n"
        "#endif\n";

    namespace detail {
        static const std::unordered_map<std::string, std::string> s_jitsafe_headers = {
            { "float.h",     jitsafe_header_float_h     },
            { "limits.h",    jitsafe_header_limits_h    },
            { "stdint.h",    jitsafe_header_stdint_h    },
            { "stddef.h",    jitsafe_header_stddef_h    },
            { "stdio.h",     jitsafe_header_stdio_h     },
            { "iterator",    jitsafe_header_iterator    },
            { "limits",      jitsafe_header_limits      },
            { "type_traits", jitsafe_header_type_traits },
            { "utility",     jitsafe_header_utility     },
            { "math.h",      jitsafe_header_math_h      },
            { "complex",     jitsafe_header_complex     },
            { "algorithm",   jitsafe_header_algorithm   },
            { "stdlib.h",    jitsafe_header_stdlib_h    },
            { "assert.h",    jitsafe_header_assert_h    },

            { "iostream",    jitsafe_header_iostream    },
            { "cfloat",      jitsafe_header_float_h     },
            { "cassert",     jitsafe_header_assert_h    },
            { "cstdlib",     jitsafe_header_stdlib_h    },
            { "cmath",       jitsafe_header_math_h      },
            { "cstdio",      jitsafe_header_stdio_h     },
            { "cstddef",     jitsafe_header_stddef_h    },
            { "cstdint",     jitsafe_header_stdint_h    },
            { "climits",     jitsafe_header_limits_h    }
        };
    }
}
